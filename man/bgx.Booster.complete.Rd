% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bgx.Booster.R
\name{bgx.Booster.complete}
\alias{bgx.Booster.complete}
\title{Restore missing parts of an incomplete bgx.Booster object.}
\usage{
bgx.Booster.complete(object, saveraw = TRUE)
}
\arguments{
\item{object}{object of class \code{bgx.Booster}}

\item{saveraw}{a flag indicating whether to append \code{raw} Booster memory dump data
when it doesn't already exist.}
}
\value{
An object of \code{bgx.Booster} class.
}
\description{
It attempts to complete an \code{bgx.Booster} object by restoring either its missing
raw model memory dump (when it has no \code{raw} data but its \code{bgx.Booster.handle} is valid)
or its missing internal handle (when its \code{bgx.Booster.handle} is not valid
but it has a raw Booster memory dump).
}
\details{
While this method is primarily for internal use, it might be useful in some practical situations.

E.g., when an \code{bgx.Booster} model is saved as an R object and then is loaded as an R object,
its handle (pointer) to an internal tsoobgx model would be invalid. The majority of tsoobgx methods
should still work for such a model object since those methods would be using
\code{bgx.Booster.complete} internally. However, one might find it to be more efficient to call the
\code{bgx.Booster.complete} function explicitly once after loading a model as an R-object.
That would prevent further repeated implicit reconstruction of an internal booster model.
}
\examples{

data(agaricus.train, package='tsoobgx')
bst <- tsoobgx(data = agaricus.train$data, label = agaricus.train$label, max_depth = 2,
               eta = 1, nthread = 2, nrounds = 2, objective = "binary:logistic")
saveRDS(bst, "bgx.model.rds")

bst1 <- readRDS("bgx.model.rds")
if (file.exists("bgx.model.rds")) file.remove("bgx.model.rds")
# the handle is invalid:
print(bst1$handle)

bst1 <- bgx.Booster.complete(bst1)
# now the handle points to a valid internal booster model:
print(bst1$handle)

}
